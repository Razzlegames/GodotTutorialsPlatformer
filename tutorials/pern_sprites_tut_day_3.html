<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <meta name="generator" content="Context"><title>The Pern Project Day 3</title>

  
  <link rel="stylesheet" type="text/css" href="pern_sprites_tut_day_3_files/pern.css"></head><body>

<!--567890123456789012345678901234567890123456789012345678901234567-->

<center>
  <img src="pern_sprites_tut_day_3_files/drunkenlogo.png" alt="banner" height="80" width="425"><br>
The Nintendo Reverse Engineering Project
</center>

<h1>Day 3</h1>

<table width="100%">
<tbody><tr valign="top">
<td> <!-- main index -->
<p>
Well it is time for some sprites!<br>
Things covered in day 3 will be:
</p>
<ul>
  <li><a href="#what">What is a sprite?
  </a></li><li><a href="#what"></a><a href="#mem">Memory and sprites.
  </a></li><li><a href="#mem"></a><a href="#drawing">Displaying your first sprite.</a>
  </li><li><a href="#multi">Multiple sprites</a>
  </li><li><a href="#16col">16 Color sprites</a>
  </li><li><a href="#hi_obj">Sprites in bitmap Modes 
    (yes they are different)</a>
</li></ul>

</td><td> <!-- side pane -->
<h2>Files Needed</h2>
<h3>Tools</h3>

      <a href="http://www.drunkencoders.com/tools/GBA/pcx2sprite.zip">Pcx2Sprite</a><br>

<h3>Source</h3>
      <p><a href="http://www.drunkencoders.com/examples/GBA/tutors/gba_src.zip">source</a></p>
      </td></tr></tbody></table>

<h2><a name="what"></a>What is a sprite?</h2>
<p>
What exactly do small, fast moving, flying faeries have to do with 
computer graphics?  The term sprite has been around for a long time 
and although I have no idea who coined the term it has certainly
stuck.
</p>
<p>
Sprites generally refer to any object that moves freely from the 
background.  An obvious example is the Mario character in Super Mario 
Bros. Sprites can be any size often ranging from a few pixels to half 
the screen. They also can have any number of frames of animation. Be 
it a small, fast moving bullet or an imposing Street Fighter II 
character, sprites are what make games fun.
</p>
<p>
The most common way of rendering sprites is very similar to the way 
we drew a picture in day two. Each frame of the sprite is stored in 
a bitmap in off screen memory and is drawn to the screen pixel by 
pixel every frame. There are several problems with this. First, if 
you do not take precautions the background is destroyed. You must 
preserve it, either by redrawing the background every frame or 
storing the contents of the background that you are going to overwrite 
in a bitmap in memory, then, when the sprite has moved, replace the 
background you just copied over. The real problem is not this method&#8217;s 
complexity, but its speed.
</p>
<p>
Fortunately for us the GBA has hardware rendered sprites freeing us 
from tying up the processor with bit-blitting code.  Not to mention 
that the hardware supports such features as rotation, scaling, and 
alpha blending.
</p>
<p>

In order to render a sprite all you need to do is provide the 
graphics for the image and supply the GBA with a few pieces of 
information and you will have little Links and Marios running all
over the place.  
</p>

<h2><a name="mem"></a>Memory and sprites.</h2>
 <p>
There are two areas of concern when it comes to sprite memory. The 
first is called OAM (Object Attribute Memory). The second is 
character memory.
</p>
<p>
OAM is where the characteristics of each sprite are defined. You can 
have up to 128 sprites defined in OAM at any one time. OAM is 
arranged as a linear array starting at memory location 0x07000000.
There are 128 entries in this array each consisting of four 16-bit
attributes for a total of 1024 bytes of data.
</p>
<p>
The first 3 attributes deal with sprite attributes like position, 
size, shape, color depth, etc. The last attribute is for rotation 
data but is not actually part of that sprite (that probably makes 
no sense at this point but that is ok, I will cover in more detail 
in a moment). The most common way to define OAM is with a structure 
and most people I have seen do it like this:
</p>
<pre class="proglist"><span class="keyw">typedef struct</span> tagSprite
{
    u16 attribute0;
    u16 attribute1;
    u16 attribute2;
    u16 attribute3;
}OAM_Entry;
 
OAM_Entry OAM_Copy[128];
</pre>

<p>
This allows you to access your copy of OAM with an array and then
once each frame copy it to the real OAM. There are two reasons for 
using a copy. First OAM is locked when the screen is actually being 
drawn, meaning you can only access it during the Vblank and Hblank 
(and the Hblank only under certain circumstances). The second reason 
is that if you update OAM while your screen is not finished, you may 
actually update it when your sprite is half drawn. This will usually 
cause undesired effects like tearing (top half and bottom half don't
exactly line up). 
</p>
<p>
I actually use a slightly different structure for my OAM because 
attribute 3 really has nothing to do with that sprite. My OAM looks 
something like this.
</p>

<pre class="proglist"><span class="keyw">typedef struct</span>
{
    u16 attribute[3];
    u16 filler;
}OAM_Entry;

<span class="keyw">typedef struct</span>
{
    u16 filler1[3];
    u16 pa;
    u16 filler2[3];
    u16 pb;
    u16 filler3[3];
    u16 pc;
    u16 filler4[3];
    u16 pd;
}RotData;

OAM_Entry OAMCopy[128];
 
RotData* rotData = (RotData*) OAMCopy;
</pre>

<p>
Both my rotData array and my OAMCopy array point to the same location 
in memory causing them to overlap. This has two major benefits. One, 
it allows me to access the rotation attributes independently from the 
sprite attributes without the extra memory for another array. Two, 
it allows me to just copy the OAMCopy array into OAM every frame.  
Because attribute three is automatically updated when I access the 
rotData array, this copy takes care of both rotation attributes and 
sprite attributes. Below is a table that represents the layout of
the OAM array. This is similar to the unioning the two sets of data 
but I feel this method is much more readable.
</p>

<center>
<table border="1" cellpadding="4" cellspacing="0">
<col align="center" span="2">
<tbody><tr><th>OAMCopy[]		</th><th>rotData[0]
</th></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[0].attribute[0]
  </td><td>filler1[0]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[0].attribute[1]
  </td><td>filler1[1]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[0].attribute[2]
  </td><td>filler1[2]
</td></tr><tr>
  <td>OAMCopy[0].filler
  </td><td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">pa

</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[1].attribute[0]
  </td><td>filler2[0]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[1].attribute[1]
  </td><td>filler2[1]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[1].attribute[2]
  </td><td>filler2[2]
</td></tr><tr>
  <td>OAMCopy[1].filler
  </td><td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">pb

</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[2].attribute[0]
  </td><td>filler3[0]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[2].attribute[1]
  </td><td>filler3[1]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[2].attribute[2]
  </td><td>filler3[2]
</td></tr><tr>
<td>OAMCopy[2].filler
  </td><td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">pc

</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[3].attribute[0]
  </td><td>filler4[0]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[3].attribute[1]
  </td><td>filler4[1]
</td></tr><tr>
  <td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">OAMCopy[3].attribute[2]
  </td><td>filler4[2]
</td></tr><tr>
  <td>OAMCopy[3].filler
  </td><td style="background: rgb(204, 204, 204) none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">pd
</td></tr></tbody></table>
</center>

<p>
You may be wondering what the hell this pa, pb, pc, pd thing is. 
This is covered in the rotation portion of DAY 9. One thing you 
should notice though is that my rotData structure is 4 times as large 
as the OAMEntry structure. If you ignore the fillers the rotData 
structure accesses the attribute3 (the filler) of each OAMEntry 
structure when the arrays are pointed to the same area of memory. 
The pa, pb, pc, pd variable are the rotation attributes. There are 
a total of 32 sets of 4 rotation attributes in OAM. There can be 32 
different rotation parameters that can be applied to any number of 
sprites. All the sprites can use the same rotation attributes or you 
can have 32 independently rotating and scaling sprites. Which sprites 
go with which attributes? Well, that is up to you. Part of one of the 
attributes in each sprite tells the GBA which set of rotData to use. 
Because the 32 rotation attributes don&#8217;t correspond to any one OAM, we 
split it into two arrays even though the arrays access the same 
physical memory.
</p>
<p>
Let us look at the OAM attributes and see if we can discern how to 
display sprites.
</p>

<!-- outer table -->
<center>
<table bgcolor="#d9d9d9" border="1" cellpadding="4" cellspacing="0" width="90%">

<tbody><tr><td>
<!-- reg table -->
<table border="1" cellpadding="4" cellspacing="0">
<col align="center" span="17">
<tbody><tr><th>bits
  </th><td>F </td><td>E </td><td>D </td><td>C </td><td>B </td><td>A </td><td>9 </td><td>8
  </td><td>7 </td><td>6 </td><td>5 </td><td>4 </td><td>3 </td><td>2 </td><td>1 </td><td>0
</td></tr><tr><th>Attribute[0]
  </th><td colspan="2">Shape </td><td>C </td><td>M </td><td colspan="2">Mode </td><td>SD </td><td>R
  </td><td colspan="8">Y Coordinate
</td></tr></tbody></table>
<!-- /reg table -->

<p>
<b>Bits 0-7</b>
<!--
are the y-coordinate of your object. It is a
value between 0 and 255. 0 is the top of the screen and 159 the 
bottom. To draw a sprite that is half off the screen and at the top
then you need 255 + y (assuming that y is a negative value). The 
reason for this is that a negative y value does not work. The 
coordinate 10,-1 would actually have to be 10,254 to work as expected. 
-->
form an 8bit signed integer (range = [-128, 127]) denoting the top 
of your sprite. ANDing your sprite's top with 255 to wrap around the 
screen. For example, say that the top is int y = -1 (one pixel above 
the screen). In hex, this is 0xFFFFFFFF; -1 &amp; 255 = 0xff, which is 
indeed -1 for signed 8bit integers.<br>
<b>Bit 8</b> is the rotation scaling flag. If set it will draw the 
sprite with the scaling/rotation parameters specified.<br>
<b>Bit 9</b> is something called the size double flag and I will 
talk about this when I describe sprite rotation.  One interesting 
effect of the SD flag is that if it is set, but the rotation flag is 
not, then that sprite will not be displayed. This is how we will 
turn off all of the unused sprites and why this flag is sometimes 
referred to as the TURN_OFF flag.<br>
<b>Bits A-B</b> are the mode flags and deal with alpha blending. I
will talk about that more in chapter 9.<br>
<b>Bit C</b> is the mosaic flag. When set the sprite will have the 
mosaic value applied to it.  This topic is also saved for day 9.<br>
<b>Bit D</b> is the color mode. If set it defines the sprite as 
256-colors. If cleared it uses a 16-color palette.<br>
<b>Bit E-F</b> is the object's shape and will be described in more
detail when we actually draw our first sprite.
</p>
<br>

</td></tr><tr><td>
<!-- reg table -->
<table border="1" cellpadding="4" cellspacing="0">
<col align="center" span="17">
<tbody><tr><th>bits
  </th><td>F </td><td>E </td><td>D </td><td>C </td><td>B </td><td>A </td><td>9 </td><td>8
  </td><td>7 </td><td>6 </td><td>5 </td><td>4 </td><td>3 </td><td>2 </td><td>1 </td><td>0
</td></tr><tr><th>Attribute[1]
  </th><td colspan="2">Size </td><td>VF </td><td>HF </td><td colspan="3">RotData index
  </td><td colspan="9">X Coordinate
</td></tr></tbody></table>
<!-- /reg table -->
<p>
<b>Bits 0-8</b>
<!-- are the x-coordinate of the sprite. Since the GBA screen is 
much wider than it is tall it needs an extra bit. 0 is left 240 is 
right and to draw off screen and to the left the equation is x = 
512 + x (were x is the actual x coordinate and a negative number).
-->
form the left of the sprite. Similar to the top, these 9 bits form 
a signed integer, with the range [-256, 255]. This time, AND with 
511 for correct wrapping.<br>
<b>Bits 9-13</b> serve a dual purpose. If the rotation scaling flag 
is set in attribute[0] then they are the 5-bit index (0-31) into the 
rotData array and define which set of rot/scaling parameters are 
going to be used with that sprite. If the rotation scaling flag is not
set then bits 9-11 are not used.<br>
<b>Bit 12 is</b> the horizontal flip flag (the sprite will be flipped 
along the y axis) and bit 13 is the vertical flip flag (x axis). 
These attributes are not used when the rotation flag is set in 
attribute[0].<br>
<b>Bit 14-15</b> is the size and I will give you a nice little table 
that explains the use of this flag and the shape flag when we draw
our first sprite.
</p>

</td></tr><tr><td>
<!-- reg table -->
<table border="1" cellpadding="4" cellspacing="0">
<col align="center" span="17">
<tbody><tr><th>bits
  </th><td>F </td><td>E </td><td>D </td><td>C </td><td>B </td><td>A </td><td>9 </td><td>8
  </td><td>7 </td><td>6 </td><td>5 </td><td>4 </td><td>3 </td><td>2 </td><td>1 </td><td>0
</td></tr><tr><th>Attribute[2]
  </th><td colspan="4">Palette number </td><td colspan="2">Priority
  </td><td colspan="10">Character Name
</td></tr></tbody></table>
<!-- /reg table -->
<p>
<b>Bit 0-9</b> is the index into sprite character memory of the first 
8x8 tile of the sprite (to fully understand this flag wait until I
describe the second area of sprite memory).<br>
<b>Bit 10-11</b> is the priority. As with backgrounds sprites can be 
assigned a priority of 0-3. Higher numbered sprites are drawn first,
meaning that a sprite of priority 0 will be drawn over the top of a 
sprite with priority of 3. Also, a sprite priority is always higher 
than that of the corresponding background priority meaning that if 
both a sprite and a background have the same priority then the sprite
will be drawn on top. One more thing: for sprites with the same 
priority then sprites with the lowest OAM number are drawn on top.<br>
<b>Bits 12-15</b> are the palette number. If your sprite is a 16-color
sprite then this value will determine which of the 16 16-color 
palettes are used. If it is a 256-color sprite then these bits are 
ignored.<br>
</p>
</td></tr></tbody></table>
</center>

<p>
Well that pretty much sums up OAM memory, except it does nothing for 
rotation attributes; that will come later when I talk about rotation 
and scaling. The next area is character memory and this is where 
your sprite character data is stored (the bitmaps of your sprite).
</p>
<p>
Character data starts at 0x06010000 and extends for 32KB. It consists
of 1024 8x8 16 color tiles (256 color tiles actually take two 8x8 
slots). The character name bits in attribute[2] refer to one of these 
tiles. This makes loading graphics for sprites that are larger than 
8x8 awkward. Fortunately, I have written a tool that will cut your 
sprite bitmap into 8x8 tiles that can be loaded much easier into 
sprite memory.
</p>
<p>
The problem with this set up is that bitmap modes (modes 3, 4, and 5) 
actually extend into the character data area of memory cutting it 
in half. This means that only character names greater than 511 are
allowed in the bitmap modes.
</p>
<p>
The tiles can be arranged in one of two user definable ways: 1D
(1 dimensional) and 2D. If the 1D flag in REG_DISPCNT is set then the 
layout is 1D, otherwise it is 2D. First I will explain 2D mode.
</p>
<p>
2D mode is laid out as a big square of 8x8 tiles. The table is 32 
tiles wide and 32 tall. The Character Name in attribute[2] points to 
one of these tiles. Here is a picture that may help.
</p>

<table border="1" cellpadding="1" cellspacing="0">
<caption align="bottom">
<span style="background: magenta none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  8x8 16-color sprite; Character name= 32</span><br>
<span style="background: lime none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  8x8 256-color sprite; Character name = 0</span><br>
<span style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  16x16 256-color sprite; Character name = 36</span><br>
<span style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  64x64 256-color sprite; Character name = 16</span><br>
</caption>
<col align="center" span="32" width="24">
<tbody><tr>
  <td style="background: lime none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">0</td><td style="background: lime none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">1
  </td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7
  </td><td>8</td><td>9</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">16 </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">17
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">18 </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">19 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">20 </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">21
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">22</td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">23

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">30 </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">31
</td></tr><tr>
  <td style="background: magenta none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">32 </td><td>33 </td><td>34 </td><td>35
  </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">36 </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">37
  </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">62 </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">63
</td></tr><tr>
  <td>64 </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp;
  </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">68 </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
</td></tr><tr>
  <td>96</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
</td></tr><tr>
  <td>128</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
</td></tr><tr>
  <td>160</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
</td></tr><tr>
  <td>192</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 

</td></tr><tr>
  <td>224</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp;
  </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; </td><td style="background: orange none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">&nbsp; 

</td></tr><tr>
  <td>256</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;

  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;
</td></tr></tbody></table>

<p>
To compute the actual memory address of a character the following 
equation will work. 0x06010000 + (CharName * 8x4) = addressOfChar. 
0x06010000 is the start address of character memory and each character 
is 32 bytes due to the fact that they are 16-color by default. Storing 
of the graphics into the character memory must be done one tile at a 
time which is why a tool to strip the bitmaps into a strip of tiles 
is necessary.
</p>
<p>
The next mode is just a big stack of tiles that are only one wide 
and 1024 tall (512 if 256 color). This mode may seem less intuitive, 
but is actually the most common. In fact it is easier. The major 
benefit to this mode comes into play when you consider the work 
necessary to copy a sprite from your ROM to video memory. In 2D mode 
you have to copy your bitmap tile by tile into video memory keeping 
track of the width of the video memory (32 tiles). This adds a 
separate step that can be a significant slowdown when you need to 
change out sprite graphics often. With 1D mode you can copy the data 
straight into video memory, assuming your sprite is already broken 
down. This enables the easy use of DMA (direct memory access is a 
very fast memory copy done by hardware and will be discussed later) 
to copy sprite data into memory. I have found no real use for 2D mode 
and do not use it myself. I am sure there is a reason, but I do not
know what that could be. Here is a picture of 1D mode:
</p>

<center>
<table border="1" cellpadding="2" cellspacing="0">

<!-- horizontal version -->
<col style="background: magenta none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" span="1" width="16">
<col style="background: lime none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" span="2" width="16">
<col style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" span="8" width="16">
<tbody><tr>
  <td> 0
  </td><td> 1 </td><td> 2
  </td><td> 3 </td><td> 4 </td><td> 5 </td><td> 6 </td><td> 7 </td><td> 8 </td><td> 9 </td><td>10
  </td><td>11 </td><td>12 </td><td>13 </td><td>14 </td><td>15 </td><td>&#8230;


<!-- vertical version -->
<!--
<tr><td>15 <tr><td>14 <tr><td>13 <tr><td>12 <tr><td>11

<tr><td style="background:cyan;">10
<tr><td style="background:cyan;">9
<tr><td style="background:cyan;">8
<tr><td style="background:cyan;">7
<tr><td style="background:cyan;">6
<tr><td style="background:cyan;">5
<tr><td style="background:cyan;">4
<tr><td style="background:cyan;">3

<tr><td style="background:lime;">2
<tr><td style="background:lime;">1

<tr><td style="background:magenta;">0
-->
</td></tr></tbody></table>
</center>
<p>
<span style="background: magenta none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  8x8 16-color sprite; Character name= 0</span><br>
<span style="background: lime none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  8x8 256-color sprite; Character name = 1</span><br>
<span style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
  16x16 256-color sprite; Character name = 3</span><br>
</p>

<p>
The 16x16 256-color sprite is arranged like this:
</p>
<center>
<table border="1" cellpadding="2" cellspacing="0">
<col style="background: cyan none repeat scroll 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" span="4" width="16"><tbody><tr>
  <td> 3 </td><td> 4 </td><td> 5 </td><td> 6
</td></tr><tr>
  <td> 7 </td><td> 8 </td><td> 9 </td><td>10
</td></tr></tbody></table>
</center>

<p>
This means that a tile by tile copy of the sprite graphics into 
character memory is not interrupted by the checking for the width of 
character memory. In 2D you would have to load the first 4 tiles 
into memory and then recomputed the offset into character memory 
for the next row of tiles, but 1D always wraps around.
</p>
<p>
Well that about sums up the memory and formats used by sprites; now
I suppose you want to draw a few.
</p>

<h2><a name="drawing"></a>Drawing your first sprite</h2>
<p>
First let&#8217;s do a 1D demo and then a 2D one. Before we do anything, 
we need to define all these bits we just talked about so we can set 
our attributes in some readable fashion.  You will find these 
defines in "gba_video.h"

</p><pre class="proglist"><span class="cmt">//sprite defines
//Atribute0 stuff</span>
<span class="keyw">#define</span> ROTATION_FLAG      BIT8
<span class="keyw">#define</span> SIZE_DOUBLE        BIT9
<span class="keyw">#define</span> SPRITE_OFF         BIT9
<span class="keyw">#define</span> MODE_NORMAL        0
<span class="keyw">#define</span> MODE_TRANSPARENT   BIT(0xA)
<span class="keyw">#define</span> MODE_WINDOWED      BIT(0xB)
<span class="keyw">#define</span> MOSAIC             BIT(0xC)
<span class="keyw">#define</span> COLOR_16           0
<span class="keyw">#define</span> COLOR_256          BIT(0xD)
<span class="keyw">#define</span> SQUARE             0
<span class="keyw">#define</span> TALL               BIT(0xF)
<span class="keyw">#define</span> WIDE               BIT(0xE)

<span class="cmt">//Atribute1 stuff</span>
<span class="keyw">#define</span> ROTDATA(n)         ((n) &lt;&lt; 9)
<span class="keyw">#define</span> HORIZONTAL_FLIP    BIT(0xC)
<span class="keyw">#define</span> VERTICAL_FLIP      BIT(0xD)
<span class="keyw">#define</span> SIZE_8             0
<span class="keyw">#define</span> SIZE_16            BIT(0xE)
<span class="keyw">#define</span> SIZE_32            BIT(0xF)
<span class="keyw">#define</span> SIZE_64            BIT(0xF) | BIT(0xE)
 
<span class="cmt">//atribute2 stuff</span>
<span class="keyw">#define</span> PRIORITY(n)        ((n) &lt;&lt; 10)
<span class="keyw">#define</span> PALETTE(n)         ((n) &lt;&lt; 12)
</pre>

<p>
These defines should be self explanatory; if not, refer to the
descriptions of the attributes above.
</p>
<p>
To clarify the relation between the size and shape flags here is a 
handy table.
</p>

<center>
<table border="1" cellpadding="2" cellspacing="0">
<tbody><tr><th>&nbsp;	</th><th>SIZE_8	</th><th>SIZE_16	</th><th>SIZE_32	</th><th>SIZE_64
</th></tr><tr><th>SQUARE	</th><td>8x8		</td><td>16x16	</td><td>32x32	</td><td>64x64
</td></tr><tr><th>TALL	</th><td>8x16	</td><td>8x32	</td><td>16x32	</td><td>32x64
</td></tr><tr><th>WIDE	</th><td>16x8	</td><td>32x8	</td><td>32x16	</td><td>64x32
</td></tr></tbody></table>
</center>

<h3>DEMO 1</h3>
<p>
The first thing we must do is create some graphics for our sprite.
To do that, we are again going to use a PCX file, but this time we 
are going to let the PC process our data. You will need PCX2Sprite if 
you have not already downloaded it. This file takes as an input a 
PCX file and produces an object file, a raw binary, or a c file that
contains the sprite graphics chopped up to fit into sprite memory. It 
also produces a header file for easy access to the data. Open your
favorite graphics editor and create a 64x64 image.  Ensure the palette
is 256 colors and then save as sprite.pcx.  Here is my image:
</p>

<p align="center">
<img src="pern_sprites_tut_day_3_files/image002.htm" alt="demo image"><br>
(yes, I drew it myself)<br>
(no, it is not a self portrait)<br>
</p>

<p>
Color zero, no matter its RGB value, will not be rendered onto the 
GBA screen so use this to color the portions of your image that you 
do not want blitted.
</p>
<p>
PCX2Sprite.exe takes several parameters. For a single sprite with one 
frame of animation just use: pcx2Sprite input.pcx.
</p>
<p>
An object file will be produced with a header file for easy access. 
Look in the readme to see the other options.
</p>
<p>
Let us delve into the world of sprites with our first single sprite 
demo.  This demo places a single 256-color 64x64 sprite on the screen 
and allows you to move it about with your direction pad. It also
enables or disables the vertical and horizontal flip flags with the 
A and B buttons.  As usual here is the full source to the demo after 
which we will step through the code.
</p>

<pre class="proglist"><span class="keyw">#include</span> <span class="str">"gba.h"</span>
<span class="keyw">#include</span> <span class="str">"sprite.h"</span>
 
<span class="cmt">//global data</span>
OAMEntry OAMCopy[128];
 
<span class="cmt">//a simple sprite structure</span>
<span class="keyw">typedef struct</span>
{
   <span class="keyw">int</span> x,y;
   OAMEntry* oam;
   <span class="keyw">int</span> gfxID;
}Sprite;
 
<span class="cmt">//from day 2, our wait for Vblank</span>
<span class="keyw">void</span> WaitForVblank(<span class="keyw">void</span>)
{
   <span class="keyw">while</span>(! (REG_DISPSTAT &amp; DISPSTAT_VB));
   <span class="keyw">while</span>(REG_DISPSTAT &amp; DISPSTAT_VB);
}
 
<span class="cmt">//turn all the sprites off</span>
<span class="keyw">void</span> InitOAM(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> i;
 
   <span class="keyw">for</span>(i = 0; i &lt; 128; i++)
      OAMCopy[i].attribute[0] = SPRITE_OFF;
}


<span class="cmt">// Copy our OAMcopy to OAM</span>
<span class="keyw">void</span> UpdateOAM(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> i;

   <span class="keyw">for</span>(i = 0; i &lt; 128 * <span class="keyw">sizeof</span>(OAMEntry) / 4 ; i++)
      ((u32*)OAMMem)[i] = ((u32*)OAMCopy)[i];
}

<span class="cmt">// Test for key presses and move the sprite</span>
<span class="keyw">void</span> GetInput(Sprite* sp)
{
   <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_UP))
      sp-&gt;y--;
 
   <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_DOWN))
      sp-&gt;y++;

   <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_LEFT))
      sp-&gt;x--;
 
   <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_RIGHT))
      sp-&gt;x++;
 
   <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_A))
      sp-&gt;oam-&gt;attribute[1] ^= HORIZONTAL_FLIP;

   if(!(REG_KEYS &amp; KEY_B))
      sp-&gt;oam-&gt;attribute[1] ^= VERTICAL_FLIP;

}
 
<span class="cmt">// Update the sprites OAM entry to reflect <!--
-->new position</span>
<span class="keyw">void</span> MoveSprite(Sprite* sp)
{
   sp-&gt;oam-&gt;attribute[1] &amp;= 0xFE00;
   sp-&gt;oam-&gt;attribute[1] |= (sp-&gt;x &amp; 0x01FF);
 
   sp-&gt;oam-&gt;attribute[0] &amp;= 0xFF00;
   sp-&gt;oam-&gt;attribute[0] |= (sp-&gt;y &amp; 0x00FF);
}  
 
 
<span class="cmt">// main entry point</span>
<span class="keyw">int</span> main(<span class="keyw">void</span>)
{
   Sprite sprite1;
   <span class="keyw">int</span> i;
 
   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D);
 
   InitOAM();
 
   <span class="cmt">//init our sprite</span>
   sprite1.oam = &amp;OAMCopy[0];
   sprite1.x = 10;
   sprite1.y = 10;
   sprite1.gfxID = 0;

   <span class="cmt">//set up our sprites OAM entry attributes</span>
   sprite1.oam-&gt;attribute[0] = COLOR_256 | SQUARE;  
   sprite1.oam-&gt;attribute[1] = SIZE_64;
   sprite1.oam-&gt;attribute[2] = sprite1.gfxID;
 
   <span class="cmt">//copy the sprite grahics in obj graphics mem</span>
   <span class="keyw">for</span>(i = 0; i &lt; 64 * 64 / 2; i++)
      OBJ_GFXMem[sprite1.gfxID * 16 + i] = spriteData[i];  
 
   <span class="cmt">//copy in the palette</span>
   <span class="keyw">for</span>(i = 0; i &lt; 256; i++)
      OBJPaletteMem[i] = spritePalette[i];   

   <span class="cmt">//main loop</span>
   <span class="keyw">while</span>(1)
   {
      GetInput(&amp;sprite1);
      MoveSprite(&amp;sprite1);
      WaitForVblank();
      UpdateOAM();   
   }
 }
</pre>

<p>
Let us step through the code.
</p>

<pre class="proglist"><span class="cmt">//global data</span>
OAMEntry OAMCopy[128];

<span class="cmt">//a simple sprite structure</span>
<span class="keyw">typedef struct</span>
{
   <span class="keyw">int</span> x,y;
   OAMEntry* oam;
   <span class="keyw">int</span> gfxID;
}Sprite;
</pre>

<p>
First we declare our OAM copy that holds our mirror of the 
OAM entries.  Again the reason this is necessary is because there 
are times when OAM attribute memory is locked and this allows us to
write attributes anytime without worrying about the state of the 
screen update.
</p>
<p>
Next we define a simple sprite structure that holds all the data 
our sprite will need.  An x and a y value and a pointer to its OAM 
entry.  Also we have an ID that will point to its graphics (the ID is 
just a representation of the offset into sprite graphics memory of 
the first tile of the sprite).
</p>

<pre class="proglist"><span class="cmt">//turn all the sprites off</span>
<span class="keyw">void</span> InitOAM(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> i;
 
   <span class="keyw">for</span>(i = 0; i &lt; 128; i++)
      OAMCopy[i].attribute[0] = SPRITE_OFF;
}


<span class="cmt">// Copy our OAMcopy to OAM</span>
<span class="keyw">void</span> UpdateOAM(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> i;

   <span class="keyw">for</span>(i = 0; i &lt; 128 * <span class="keyw">sizeof</span>(OAMEntry) / 4 ; i++)
      ((u32*)OAMMem)[i] = ((u32*)OAMCopy)[i];
}
</pre>

<p>
These two functions initialize and update our sprites. The first just 
sets all the OAM entries to &#8220;off&#8221; so that only the ones 
we turn on will be displayed. If this is not done then all of the 
unused entries will be active and end up showing up in the upper left 
hand corner of the screen as a random 8x8 box of crap.
</p>
<p>
The second function copies our OAM copy to actual OAM memory so our 
sprites will be updated. It is cast to a 32 bit pointer so we can
copy 4 bytes at a time. We will convert this to a DMA call in a later 
chapter as well as place the copy into internal working ram to speed 
things up.
</p>
<p>
Next is the getInput() function which modifies a sprite based on user 
input.  The only interesting thing it does is clear and set the flip 
flags to cause our sprite to be rendered upside down or sideways 
depending on key press.
</p>

<pre class="proglist"><span class="cmt">// main entry point</span>
<span class="keyw">int</span> main(<span class="keyw">void</span>)
{
   Sprite sprite1;
   <span class="keyw">int</span> i;

   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D);

   InitOAM();
 
   <span class="cmt">//init our sprite</span>
   sprite1.oam = &amp;OAMCopy[0];
   sprite1.x = 10;
   sprite1.y = 10;
   sprite1.gfxID = 0;
 
   <span class="cmt">//set up our sprites OAM entry attributes</span>
   sprite1.oam-&gt;attribute[0] = COLOR_256 | SQUARE;  
   sprite1.oam-&gt;attribute[1] = SIZE_64;
   sprite1.oam-&gt;attribute[2] = sprite1.gfxID;
 }
</pre>

<p>
The code for main is pretty straightforward.  We set our mode and 
enable the sprites and set the mapping mode to 1D.  We then 
initialize our sprite by assigning its OAM and its position, and let 
it know we are going to use the beginning of sprite graphics memory to 
place our sprite graphics (gfxID = 0).  Finally, we set the attributes
for the OAM to create a 64x64 256-color sprite.  Notice that we assign 
attribute[2] the value for the beginning of sprite graphics; this 
location is often referred to as the sprite (or object) character
name.
</p>

<pre class="proglist">   <span class="cmt">//copy the sprite grahics in obj graphics mem</span>
   <span class="keyw">for</span>(i = 0; i &lt; 64 * 64 / 2; i++)
      OBJ_GFXMem[sprite1.gfxID * 16 + i] = spriteData[i];  
 
   <span class="cmt">//copy in the palette</span>
   <span class="keyw">for</span>(i = 0; i &lt; 256; i++)
      OBJPaletteMem[i] = spritePalette[i];
</pre>

<p>
The last thing we do is copy in our sprite graphics and palette.  
OBJ_GFXMem is defined in gba.h as 0x06010000.  We then offset that
address the correct number of sprite characters by multiplying the 
starting character by 16 (each character is based on an 8x8 16 color 
character, this is 64 pixels at 4 bits apiece for 32 bytes, or 
16 shorts which is the type of our arrays).  In our case the gfxID is 
0 so this is not needed but when we do more sprites this will become 
very important.
</p>
<p>
The palette copy is straightforward enough that it deserves little
comment. Remember, we imported the sprite data from a PCX file that
was converted with PCX2sprite to an object file that we could link 
right in.
</p>
<p>
The last part of main sticks us in an infinite loop where we grab
input and update the sprite.
</p>

<h3>Demo 2</h3>
<p>
Demo 2 simply changes the mapping mode to 2D so we can see the 
difference.  The only change will be the way in which we copy in the
sprite data.
</p>
<p>
The first thing we must change is this:
</p>

<pre class="proglist">   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D);
</pre>
<p>
To
</p>
<pre class="proglist">   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_2D);
</pre>
 
<p>
Let us see what this change alone gives us:
</p>

<center>
<img src="pern_sprites_tut_day_3_files/image003.htm" alt="demo 2">
</center>

<p>
Hmm &#8230;  Not exactly what we want is it.  If you recall, we must
copy the data in tile row by tile row in order for 2D to work.  The
reason for this is that when we just copy in all our data we get tiles 
that look like this in tile memory:
</p>

<center>
<img src="pern_sprites_tut_day_3_files/image004.htm" alt="tile view, 1d">
</center>

<p>
This is a screen shot using 
<a href="http://bottledlight.com/">Mappy VM</a>&#8217;s tile viewer that
lets us look inside sprite graphics memory.  For 1D mode, this <i>is</i>
the way we want our tiles loaded in, but not for 2D.  This is how we 
want our tiles in 2D mode:
</p>

<center>
<img src="pern_sprites_tut_day_3_files/image005.htm" alt="tile view, 2d">
</center>

<p>
Unfortunately, Mappy VM&#8217;s sprite tile viewer is set up for 16 color 
mode. Sprite graphics memory is 32 tiles wide and 32 tall, making it 
256 pixels wide in 16 color mode.  In 256 color mode it should only be
128 pixels wide but the video viewer still wraps it at 256 pixels so 
we do not get to see the nice 2D layout that is actually occurring.
</p>
<p>
So, how do we get our tiles in memory this way?  Simple: we just copy 
in the first 8 tiles then move down a full 32 tiles, then copy the
next 8, and so on till we have all 64.  Here is some sample code that 
does just that.  Besides the change to SetMode, this is the only
difference between demo 1 and demo 2.
</p>

<pre class="proglist">   offset = sprite1.gfxID * 8 * 4 / 2;

   <span class="cmt">//copy the sprite grahics in obj graphics mem</span>
   <span class="keyw">for</span>(iy = 0; iy &lt; 8; iy++)
   {
      <span class="keyw">for</span>(ix = 0; ix &lt; 8 * 8 * 8 / 2; ix++)
      {
         OBJ_GFXMem[offset + ix] = spriteData[ix + iy * 8*8*8 / 2];
      }
      offset += 32 * 8 * 4 / 2;
    }
</pre>

<p>
First we calculate the offset into gfxMem by multiplying the sprite 
ID by the size of a tile (8 x 4, since the tiles are based on 
16-color), then divide by two because our arrays are 16 bit. We then
loop through all the tiles and copy in 8 at a time.  Every row, we
increment our offset by the size of 32 8x8 tiles.
</p>

<p>
Now let us add multiple sprites.
</p>

<h2><a name="multi"></a>Multiple Sprites</h2>

<h3>DEMO 3</h3>

<p>
Let us place a 50 or so sprites on the screen with this demo. First 
they will all use the same graphics. In the next demo we will make 
them use different graphics.
</p>
<p>
The first thing we are going to need is some way to send these guys 
off at different speeds because I certainly don&#8217;t want to move 50 
sprites around with the keyboard. It would be nice if we had a 
random number generator.  Let&#8217;s make one.
</p>
<p> The following is based on the <a href="http://www.math.sci.hiroshima-u.ac.jp/%7Em-mat/eindex.html">Mersenne 
  Twister</a> algorithm. </p>

<pre class="proglist"><span class="keyw">unsigned short</span> r256table[256];
<span class="keyw">unsigned char</span> r256index;

<span class="keyw">void</span> r256init(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> i,j,msb;
   j=42424;
   <span class="keyw">for</span>(i=0;i&lt;256;i++)
   {
      r256table[i]=(<span class="keyw">unsigned short</span>)(j=j*65539);
   }
 
   msb=0x8000;

   j=0;

   <span class="keyw">for</span>(i=0;i&lt;16;i++)
   {
      j=i*5+3;
      r256table[j]|=msb;
      r256table[j+1]&amp;=~msb;
      msb&gt;&gt;=1;
   }
}
 
<span class="keyw">unsigned short</span> r256(<span class="keyw">void</span>)
{
   <span class="keyw">int</span> r;
   r=r256table[(r256index+103)&amp;255]^r256table[r256index];
   r256table[r256index++]=r;
   <span class="keyw">return</span> r;
}
</pre>

<p>
For details on how and why it works, be sure and follow the link 
provided.  Since we have no system timer to seed the function with 
we are not going to worry about the fact that is going to give the 
same sequence of random numbers every time.  Later we will initialize
it and then call it repeatedly while waiting for the user to get past
the title screen.  This way it should be random enough by the time it 
gets used.
</p>
<p>
Now that we have a means let us get on to the ends.  Here is the 
changed code.  We added the random functions which I am not going to
re-paste.  We also changed our sprite struct to hold speed.
</p>

<pre class="proglist"><span class="keyw"> typedef int</span> FIXED32;
<span class="cmt">//a simple sprite structure</span>
<span class="keyw">typedef struct</span>
{
   FIXED32 x,y;
   OAMEntry* oam;
   <span class="keyw">int</span> gfxID;
   FIXED32 dx,dy;
}Sprite;
</pre>

<p>
dx and dy now will track our speed.  These will be fixed 24.8 values
for now and in order to use them on x and y it would be best if x and 
y were also fixed.  For a fixed point review see 
<a href="http://www.drunkencoders.com/tutorials/GBA/appendixA.html">appendix A</a>.

</p><p>
The next altered function will be MoveSprite.  This needs to be fixed 
to handle the fixed point x and y and it does that with a simple 
shift of x and y back to ints.
</p>

<pre class="proglist"><span class="cmt">// Update the sprites OAM entry to reflect <!--
-->new position</span>
<span class="keyw">void</span> MoveSprite(Sprite* sp)
{
   sp-&gt;oam-&gt;attribute[1] &amp;= 0xFE00;
   sp-&gt;oam-&gt;attribute[1] |= ((sp-&gt;x &gt;&gt; 8) &amp; 0x01FF);
 
   sp-&gt;oam-&gt;attribute[0] &amp;= 0xFF00;
   sp-&gt;oam-&gt;attribute[0] |= ((sp-&gt;y &gt;&gt; 8 ) &amp; 0x00FF);
}
</pre>

<p>
I hope this code is clear and if not please refer to the 
<a href="http://www.drunkencoders.com/tutorials/GBA/appendix_A.htm">appendix</a>.
</p>
<p>
Finally, we get to main and are able to alter our code to handle 
lots of sprites.
</p>

<pre class="proglist"><span class="keyw">#define</span> MAX_SPRITES 50
<span class="cmt">// main entry point</span>
<span class="keyw">int</span> main(<span class="keyw">void</span>)
{
   Sprite sprites[MAX_SPRITES];
   <span class="keyw">int</span> i;
   <span class="keyw">int</span> offset;

   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D); 
 
   InitOAM();
   r256init();
 
   <span class="cmt">//init our sprite</span>
   <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
   {
      sprites[i].x = 10 &lt;&lt; 8;
      sprites[i].y = 10 &lt;&lt; 8;
 
      sprites[i].dx = r256() &gt;&gt; 7;
      sprites[i].dy = r256() &gt;&gt; 7;
 
      sprites[i].gfxID = 0; 
 
      <span class="cmt">//set up our sprites OAM entry attributes</span>
      sprites[i].oam = &amp;OAMCopy[i];
 
      sprites[i].oam-&gt;attribute[0] = COLOR_256 | SQUARE;
      sprites[i].oam-&gt;attribute[1] = SIZE_64;
      sprites[i].oam-&gt;attribute[2] = sprites[i].gfxID;
   }

   offset = sprites[0].gfxID * 8 * 4 / 2;

   <span class="cmt">//copy the sprite grahics in obj graphics mem</span>
   <span class="keyw">for</span>(i = 0; i &lt; 8 * 8 * 64 / 2; i++)
   {
      OBJ_GFXMem[offset + i] = spriteData[i];  
   }

   <span class="cmt">//copy in the palette</span>
   <span class="keyw">for</span>(i = 0; i &lt; 256; i++)
      OBJPaletteMem[i] = spritePalette[i];   
 
   <span class="cmt">//main loop</span>
   <span class="keyw">while</span>(1)
   {
      <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
      {
         sprites[i].x += sprites[i].dx;
         sprites[i].y += sprites[i].dy;
 
         MoveSprite(&amp;sprites[i]);
      }
 
      WaitForVblank();
      UpdateOAM();   
   }
 }
</pre>

<p>
First you will notice that we declare an array of sprites and 
initialize them with a for loop. We assign x and y a value of 10 
(in fixed point) and then assign a random speed to the dx and dy.  
These values are shifted down by 7 so they will be no more than 
9 bits. Since they are in the form 24.8, 8 bits will be fraction 
giving them a speed between 0 and 2 pixels per frame in either 
direction.
</p>
<p>
You should also note that all sprites are assigned the same gfxID 
making them all use the same graphics.  The next demo will assign 
different graphics to all the sprites.
</p>
<p>
Finally we get to the main loop.  The call to getInput has been 
replaced by a for loop that adds the speed to x and y and then moves 
the sprite.  We don&#8217;t need to worry about going off screen because 
that is handled in the MoveSprite function.  
</p>

<h3>DEMO 4</h3>
<p>
And now we do the same, but with unique graphics for all 128 sprites.
</p><p>
</p><p>
You will notice that, since there is 32KB of sprite graphics memory
and 128 OAM entries, we can fit exactly 128 16x16 sprites
in memory. (128 * 16 * 16 = 32KB).  If we were to use 16 color
sprites instead we could fit 128 32x16 or 16x32 sprites.  When we 
cover advanced sprite topics, we will put this relation to good use
by designing memory management that takes advantage of same-sized 
sprites.
</p>

<p>
First I need some sprite graphics.  I open up paint shop and create an 
image that is 240x160 and enable my grid view at 16x16 so I can see 
where I am drawing.  I then fill up the spaces for 128 sprites, which
is nearly a full screen of graphics data.  This is the image I 
created.
</p>

<center>
<img src="pern_sprites_tut_day_3_files/image006.htm" alt="squigglies">
</center>

<p>
My only goal was to make certain that each 16x16 block had some 
graphics in it.  Now I convert it using pcx2sprite with the following 
options.
</p>

<p>
Pcx2sprite data/sprite.pcx &#8211;h:16 &#8211;w:16
</p>

<p>
This lets the converter now the size of my sprites so it groups their 
tiles together appropriately.  
</p>
<p>
Now let&#8217;s check the changes we must make to the source in order for 
this to work like we want.  The only change is to main().
</p>

<pre class="proglist"><span class="keyw">#define</span> MAX_SPRITES 128
<span class="cmt">// main entry point</span>
<span class="keyw">int</span> main(<span class="keyw">void</span>)
{
   Sprite sprites[MAX_SPRITES];
   <span class="keyw">int</span> i;
   <span class="keyw">int</span> offset;
 
   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D); 
 
   InitOAM();
   r256init();
 
   <span class="cmt">//init our sprite</span>
   <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
   {
      sprites[i].x = ((i % 15) * 16) &lt;&lt; 8;
      sprites[i].y = ((i / 15) * 16) &lt;&lt; 8;
 
      sprites[i].dx = r256() &gt;&gt; 7;
      sprites[i].dy = r256() &gt;&gt; 7;

      sprites[i].gfxID = i * 8; 

      <span class="cmt">//set up our sprites OAM entry attributes</span>
      sprites[i].oam = &amp;OAMCopy[i];
 
      sprites[i].oam-&gt;attribute[0] = COLOR_256 | SQUARE;  
      sprites[i].oam-&gt;attribute[1] = SIZE_16;
      sprites[i].oam-&gt;attribute[2] = sprites[i].gfxID; 
 
      MoveSprite(&amp;sprites[i]);
   }
 
   offset = sprites[0].gfxID * 8 * 4 / 2;
 
   <span class="cmt">//copy the sprite graphics in obj graphics mem</span>
   <span class="keyw">for</span>(i = 0; i &lt; 16 * 16 * 128 / 2; i++)
   {
      OBJ_GFXMem[offset + i] = spriteData[i];  
   }
 
   <span class="cmt">//copy in the palette</span>
   <span class="keyw">for</span>(i = 0; i &lt; 256; i++)
      OBJPaletteMem[i] = spritePalette[i];   

   <span class="cmt">//main loop</span>
   <span class="keyw">while</span>(1)
   {
      <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_A))
      {
         <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
         {
            sprites[i].x += sprites[i].dx;
            sprites[i].y += sprites[i].dy;
 
            MoveSprite(&amp;sprites[i]);
         }
      }
      WaitForVblank();
      UpdateOAM();   
   }
 }
</pre>

<p>
The first thing you should notice is that all 128 sprites are enabled. 
You can edit demo 3 and display all 128 sprites as well, but keep in 
mind there are hardware limits to the amount of sprites per scan line 
that can be rendered. These limits are an advanced topic and will be 
covered on day 9.
</p>
<p>
We then initialize the sprites as before with the following 
differences: we set x and y so they fill up the screen in a nice 
pattern and recreate our original image. Also, we want each sprite to 
use different graphics this time.
</p>
<p>
All we have to do is point the OAM attribute[2] to the correct place. 
Since each sprite is exactly 4 characters from the last (16x16 needs 
4 tiles since tiles are 8x8) and each character counts as 2 tiles 
in 256-color mode we simply multiply the sprite index by 8. 
This is done in the following line:
</p>

<pre class="proglist">      sprites[i].gfxID = i * 8;
</pre>

<p>
If the sprites were instead 8x8 then they would only take up 2 
characters in 256-color mode and the line could be modified to:
</p>

<pre class="proglist">      sprites[i].gfxID = i * 2;
</pre>

<p>
Another change is made to ensure our sprite is 16x16 by making the 
shape square and the size 16.
</p>
<p>
Since we have 128 sprites to copy in this time instead of 1, our 
for loop gets a slight modification to allow for more data 
(for( i = 0; i &lt; 128 * 16 * 16 / 2; i++) ).
</p>
<p>
Finally, we come to the main loop which is nearly identical to before. 
The only change I made was that the sprites will not move unless you 
press the A key.  This way you can see them in their nice, orderly
rows that I took the time to set up with:
</p>

<pre class="proglist">   <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
   {
      sprites[i].x = ((i % 15) * 16) &lt;&lt; 8;
      sprites[i].y = ((i / 15) * 16) &lt;&lt; 8;
</pre>

<p>
That is it for simple 256-color sprites.  Let&#8217;s do one more demo 
for 16-color sprites and call it a day.
</p>

<h2><a name="16col"></a>16-Color Sprite</h2>

<h3>DEMO 5</h3>

<p>
Really the major change necessary for this demo will be in graphics
creation and conversion. I actually had to sit down and add support 
to my converter for 16-color sprites and that took longer than 
changing the demo.
</p>
<p>
Pcx2sprite data/sprite.pcx &#8211;h:16 &#8211;w:16 <span class="rem">-16</span>
</p>

<p>
The only change to the code is the init of the sprites to 16-color 
and the change of gfxID index to i * 4 instead of i * 8 since the 
16x16 sprites use half the tiles in 16-color mode. Here is the init 
code; no explanation follows because it is identical to the operation 
of the above code.
</p>
<p>
One thing of note is that in order for my converter to process 
16 color tiles only colors from the first 16 palette entries can be 
used.  There is no palette quantizing or any such thing in my simple 
converter.  This is a limitation that I may fix one of these days.
</p>
<p>
All changes from the 256 color demo are highlighted in red.  
</p>

<pre class="proglist"><span class="keyw">#define</span> MAX_SPRITES 128
<span class="cmt">// main entry point</span>
<span class="keyw">int</span> main(<span class="keyw">void</span>)
{
   Sprite sprites[MAX_SPRITES];
   <span class="keyw">int</span> i;
   <span class="keyw">int</span> offset;
 
   SetMode(MODE_0 | OBJ_ENABLE | OBJ_MAP_1D); 
 
   InitOAM();
   r256init();
 
   <span class="cmt">//init our sprite</span>
   <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
   {
      sprites[i].x = ((i % 15) * 16) &lt;&lt; 8;
      sprites[i].y = ((i / 15) * 16) &lt;&lt; 8;
 
      sprites[i].dx = r256() &gt;&gt; 7;
      sprites[i].dy = r256() &gt;&gt; 7;

      <span class="chng">sprites[i].gfxID = i * 4;</span>

      <span class="cmt">//set up our sprites OAM entry attributes</span>
      sprites[i].oam = &amp;OAMCopy[i];
 
      sprites[i].oam-&gt;attribute[0] = <span class="chng">COLOR_16</span> | SQUARE;
      sprites[i].oam-&gt;attribute[1] = SIZE_16;
      sprites[i].oam-&gt;attribute[2] = sprites[i].gfxID;

      MoveSprite(&amp;sprites[i]);
   }
 
   offset = sprites[0].gfxID * 8 * 4 / 2;
 
   <span class="cmt">//copy the sprite graphics in obj graphics mem</span>
   <span class="keyw">for</span>(i = 0; i &lt; <span class="chng">16 * 16 * 128 / 4</span>; i++)
   {
      OBJ_GFXMem[offset + i] = spriteData[i];  
   }

   <span class="cmt">//copy in the palette</span>
   <span class="chng"><span class="keyw">for</span>(i = 0; i &lt; 16; i++)</span>
      OBJPaletteMem[i] = spritePalette[i];

   <span class="cmt">//main loop</span>
   <span class="keyw">while</span>(1)
   {
      <span class="keyw">if</span>(!(REG_KEYS &amp; KEY_A))
      {
         <span class="keyw">for</span>(i = 0; i &lt; MAX_SPRITES; i++)
         {
            sprites[i].x += sprites[i].dx;
            sprites[i].y += sprites[i].dy;
 
            MoveSprite(&amp;sprites[i]);
         }
      }
      WaitForVblank();
      UpdateOAM();   
   }
 }
</pre>

<h2><a name="hi_obj"></a>Sprites in Bit Map Modes 
(mode 3, 4, and 5)</h2>

<p>
For an interesting test, change the call to setmode in demo 4 so that 
it places the GBA into one of the 3 bit map modes. If you do this, 
this is what you will see:
</p>

<center>
<img src="pern_sprites_tut_day_3_files/image007.htm" alt="half sprites">
</center>

<p>
What happened to the firs half of our sprites?!
</p>
<p>
Well, it turns out that bitmap modes are greedy, and in order to fit
all their data into video memory they need to borrow from sprite 
graphics memory.  How much do they take?  Exactly half. This means 
that any sprite gfx ID you use that is below 512 will now be in 
regular video memory and hence not be rendered by the GBA.  
Your sprites are still there, but the GBA can&#8217;t find any graphics for 
them, so they are blank.
</p>
<p>
In bitmapped modes, ensure that your character name (or sprite ID or
Object name what ever you choose to call it) does not reference the 
first 512 tiles of sprite graphics memory as these will be 
unavailable to you. Instead, begin ID assigning at 512.
</p>
<p>
That is all we have time for today.  We will revisit sprites and 
cover the more advanced topics on Day 9.  Those topics will include: 
Rotation, Scaling, Animation, Mosaic, memory management, and
exceeding the 128 sprite limit.
</p>

<center>
  <a href="http://www.drunkencoders.com/tutorials/GBA/day_2.html">Day 2</a> | <a href="http://www.drunkencoders.com/tutorials/GBA/tutorial_4.html">Day 4</a> 
</center>

<!-- standard picture
<center>
<img src="day_3_files/image003.gif" alt="demo 2">
</center>
-->


</body></html>