

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">

<head profile="http://gmpg.org/xfn/11">
  <meta http-equiv="Content-Type"
    content="text/html; charset=UTF-8" />

  <title>Coranac &raquo; memcpy and memset replacements for GBA/NDS</title>

  <!-- leave this for stats please -->
    <meta name="generator" content="WordPress 2.7.1" />

  <style type="text/css">
    @import url( http://www.coranac.com/wordpress/wp-content/themes/crn/style.css );
  </style>

  <script language="JavaScript" type="text/javascript" src="http://www.coranac.com/crn.js"></script>

  <link rel="alternate" type="application/rss+xml" title="RSS 2.0"
    href="http://www.coranac.com/feed/" />
  <link rel="alternate" type="text/xml" title="RSS .92"
    href="http://www.coranac.com/feed/rss/" />
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3"
    href="http://www.coranac.com/feed/atom/" />

  <link rel="pingback" href="http://www.coranac.com/wordpress/xmlrpc.php" />
		<link rel='archives' title='June 2009' href='http://www.coranac.com/2009/06/' />
	<link rel='archives' title='May 2009' href='http://www.coranac.com/2009/05/' />
	<link rel='archives' title='April 2009' href='http://www.coranac.com/2009/04/' />
	<link rel='archives' title='February 2009' href='http://www.coranac.com/2009/02/' />
	<link rel='archives' title='December 2008' href='http://www.coranac.com/2008/12/' />
	<link rel='archives' title='November 2008' href='http://www.coranac.com/2008/11/' />
	<link rel='archives' title='September 2008' href='http://www.coranac.com/2008/09/' />
	<link rel='archives' title='August 2008' href='http://www.coranac.com/2008/08/' />
	<link rel='archives' title='June 2008' href='http://www.coranac.com/2008/06/' />
	<link rel='archives' title='May 2008' href='http://www.coranac.com/2008/05/' />
	<link rel='archives' title='April 2008' href='http://www.coranac.com/2008/04/' />
	<link rel='archives' title='February 2008' href='http://www.coranac.com/2008/02/' />
	<link rel='archives' title='January 2008' href='http://www.coranac.com/2008/01/' />
	<link rel='archives' title='December 2007' href='http://www.coranac.com/2007/12/' />
	<link rel='archives' title='November 2007' href='http://www.coranac.com/2007/11/' />
	<link rel='archives' title='October 2007' href='http://www.coranac.com/2007/10/' />
	<link rel='archives' title='June 2007' href='http://www.coranac.com/2007/06/' />
	<link rel='archives' title='April 2007' href='http://www.coranac.com/2007/04/' />
	<link rel='archives' title='March 2007' href='http://www.coranac.com/2007/03/' />
	<link rel='archives' title='February 2007' href='http://www.coranac.com/2007/02/' />
	<link rel='archives' title='January 2007' href='http://www.coranac.com/2007/01/' />
	<link rel='archives' title='August 2006' href='http://www.coranac.com/2006/08/' />
		<link rel="stylesheet" href="http://www.coranac.com/wordpress/wp-content/plugins/codesnippet/codesnippet.css" type="text/css" />
<style type="text/css">
.codesnip-container	{border:1px solid #ccc; background:#eee; padding: 5px;margin:10px;}
</style>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.coranac.com/wordpress/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://www.coranac.com/wordpress/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 2.7.1" />

</head>

<body onload="main();">
<div id="rap">
<h1 id="header">
	<a href="http://www.coranac.com/">Coranac</a>
</h1>

<div id="content">
<!-- end header -->

<div class="post" id="post-38">
	<div class="storyheader">
		<h3 class="storytitle"><a href="http://www.coranac.com/2008/01/25/tonccpy/" rel="bookmark">
		memcpy and memset replacements for GBA/NDS</a></h3>
		<div class="meta">
		2008-01-25 &ndash; 16:54 | <ul class="post-categories">
	<li><a href="http://www.coranac.com/category/code/" title="View all posts in code" rel="category tag">code</a></li>
	<li><a href="http://www.coranac.com/category/proj/tonc/" title="View all posts in tonc" rel="category tag">tonc</a></li></ul>. 
		</div>
	</div>
	<div class="storycontent">
		<p>
The standard C functions for copying and filling are <code>memcpy()</code> 
and <code>memset()</code>. They're part of the standard library, are easy 
to use and are often implemented with some optimizations so that they're 
usually faster than manual looping. The DKA version, for example will fill as 
words if the alignments and sizes allow for it. This can be <a href="http://www.coranac.com/tonc/text/text.htm#tbl-txt-se2"><i>much</i> 
faster than doing the loops yourself</a>.
</p>
<p>
There is, however, one small annoying fact about these two: they're not 
VRAM-safe. If the alignment and size aren't right for the word transfers, 
they will transfer bytes. Not only will this be slow, of course, but because 
you can't write to VRAM in bytes, the data will be corrupted.
</p>
<p>
The solutions for this have mostly come down to &ldquo;so don't do that 
then&rdquo;. Often, this can be sufficient: tiles in VRAM are word-aligned by definition, and source graphics data can and should be word-aligned anyway. However, now that
I'm finally working on a bitmap blitter for 8bpp and 16bpp, I find that it's 
simply not enough. So I wrote the following set of functions to serve as 
replacements.
</p>

<h4>The code</h4>
<p>
My main goal here was to create smallish and portable replacements, not to 
have the greatest and fastestest code around because that's rather platform 
dependent. Yes, even the difference between GBA and NDS should matter, 
because of the differences in <code>ldr/str</code> times and caching.
</p>
<p>
There are 5 functions here. The main functions here are 
<code>tonccpy</code> and <code>__toncset</code> for copying and 
filling words, respectively. The other 3 are interfaces for <code>__toncset</code> 
for filling 8-bit, 16-bit and 32-bit data; you need these for, say, filling with a color 
instead of 8-bit data. For the rest of the discussion, I will use the name 
&ldquo;toncset&rdquo; for the internal routine for convenience. 
</p><span id="more-38"></span>

<div class="cpp"><div class="cpp proglist" style=" "><span class="co1">//# Stuff you may not have yet.</span><br />
<span class="kw1">typedef</span> <span class="kw1">unsigned</span> <span class="kw1">int</span> uint;<br />
<span class="co2">#define BIT_MASK(len) &nbsp; &nbsp; &nbsp; ( (1&lt;&lt;(len))-1 )</span><br />
<span class="kw1">static</span> <span class="kw1">inline</span> u32 quad8(u8 x) &nbsp; { &nbsp; x |= x&lt;&lt;<span class="nu0">8</span>; <span class="kw1">return</span> x | x&lt;&lt;<span class="nu0">16</span>;&nbsp; &nbsp; }<br />
<br />
<br />
<span class="co1">//# Declarations and inlines.</span><br />
<br />
<span class="kw1">void</span> tonccpy(<span class="kw1">void</span> *dst, <span class="kw1">const</span> <span class="kw1">void</span> *src, uint size);<br />
<br />
<span class="kw1">void</span> __toncset(<span class="kw1">void</span> *dst, u32 fill, uint size);<br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset(<span class="kw1">void</span> *dst, u8 src, uint size);<br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset16(<span class="kw1">void</span> *dst, u16 src, uint size);<br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset32(<span class="kw1">void</span> *dst, u32 src, uint size);<br />
<br />
<br />
<span class="co1">//! VRAM-safe memset, byte version. Size in bytes.</span><br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset(<span class="kw1">void</span> *dst, u8 src, uint size)<br />
{ &nbsp; __toncset(dst, quad8(src), size); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
<br />
<span class="co1">//! VRAM-safe memset, halfword version. Size in hwords.</span><br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset16(<span class="kw1">void</span> *dst, u16 src, uint size)<br />
{ &nbsp; __toncset(dst, src|src&lt;&lt;<span class="nu0">16</span>, size*<span class="nu0">2</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
<br />
<span class="co1">//! VRAM-safe memset, word version. Size in words.</span><br />
<span class="kw1">static</span> <span class="kw1">inline</span> <span class="kw1">void</span> toncset32(<span class="kw1">void</span> *dst, u32 src, uint size)<br />
{ &nbsp; __toncset(dst, src, size*<span class="nu0">4</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div></div>

<div class="cpp"><div class="cpp proglist" style=" "><span class="co1">//# tonccpy.c</span><br />
<br />
<span class="co1">//! VRAM-safe cpy.</span><br />
<span class="coMULTI">/*! This version mimics memcpy in functionality, with <br />
&nbsp; &nbsp; the benefit of working for VRAM as well. It is also <br />
&nbsp; &nbsp; slightly faster than the original memcpy, but faster <br />
&nbsp; &nbsp; implementations can be made.<br />
&nbsp; &nbsp; \param dst&nbsp; Destination pointer.<br />
&nbsp; &nbsp; \param src&nbsp; Source pointer.<br />
&nbsp; &nbsp; \param size Fill-length in bytes.<br />
&nbsp; &nbsp; \note &nbsp; The pointers and size need not be word-aligned.<br />
*/</span><br />
<span class="kw1">void</span> tonccpy(<span class="kw1">void</span> *dst, <span class="kw1">const</span> <span class="kw1">void</span> *src, uint size)<br />
{<br />
&nbsp; &nbsp; <span class="kw1">if</span>(size==<span class="nu0">0</span> || dst==<span class="kw2">NULL</span> || src==<span class="kw2">NULL</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span>;<br />
<br />
&nbsp; &nbsp; uint count;<br />
&nbsp; &nbsp; u16 *dst16; &nbsp; &nbsp; <span class="co1">// hword destination</span><br />
&nbsp; &nbsp; u8 &nbsp;*src8;&nbsp; &nbsp; &nbsp; <span class="co1">// byte source</span><br />
<br />
&nbsp; &nbsp; <span class="co1">// Ideal case: copy by 4x words. Leaves tail for later.</span><br />
&nbsp; &nbsp; <span class="kw1">if</span>( ((u32)src|(u32)dst)%<span class="nu0">4</span>==<span class="nu0">0</span> &amp;&amp; size&gt;=<span class="nu0">4</span>)<br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; u32 *src32= (u32*)src, *dst32= (u32*)dst;<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; count= size/<span class="nu0">4</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; uint tmp= count&amp;<span class="nu0">3</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; count /= <span class="nu0">4</span>;<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Duff, bitch!</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">switch</span>(tmp) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">do</span> {&nbsp; &nbsp; *dst32++ = *src32++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">3</span>: &nbsp; &nbsp; *dst32++ = *src32++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">2</span>: &nbsp; &nbsp; *dst32++ = *src32++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">1</span>: &nbsp; &nbsp; *dst32++ = *src32++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">0</span>: &nbsp; &nbsp; ; } <span class="kw1">while</span>(count--);<br />
&nbsp; &nbsp; &nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Check for tail</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; size &amp;= <span class="nu0">3</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span>(size == <span class="nu0">0</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span>;<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; src8= (u8*)src32;<br />
&nbsp; &nbsp; &nbsp; &nbsp; dst16= (u16*)dst32;<br />
&nbsp; &nbsp; }<br />
&nbsp; &nbsp; <span class="kw1">else</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Unaligned.</span><br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; uint dstOfs= (u32)dst&amp;<span class="nu0">1</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; src8= (u8*)src;<br />
&nbsp; &nbsp; &nbsp; &nbsp; dst16= (u16*)(dst-dstOfs);<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Head: 1 byte.</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span>(dstOfs != <span class="nu0">0</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dst16= (*dst16 &amp; <span class="nu0">0xFF</span>) | *src8++&lt;&lt;<span class="nu0">8</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst16++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span>(--size==<span class="nu0">0</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; }<br />
&nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; <span class="co1">// Unaligned main: copy by 2x byte.</span><br />
&nbsp; &nbsp; count= size/<span class="nu0">2</span>;<br />
&nbsp; &nbsp; <span class="kw1">while</span>(count--)<br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; *dst16++ = src8[<span class="nu0">0</span>] | src8[<span class="nu0">1</span>]&lt;&lt;<span class="nu0">8</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; src8 += <span class="nu0">2</span>;<br />
&nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; <span class="co1">// Tail: 1 byte.</span><br />
&nbsp; &nbsp; <span class="kw1">if</span>(size&amp;<span class="nu0">1</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; *dst16= (*dst16 &amp;~ <span class="nu0">0xFF</span>) | *src8;<br />
}</div></div>

<div class="cpp"><div class="cpp proglist" style=" "><span class="co1">//# toncset.c</span><br />
<br />
<span class="co1">//! VRAM-safe memset, internal routine.</span><br />
<span class="coMULTI">/*! This version mimics memset in functionality, with <br />
&nbsp; &nbsp; the benefit of working for VRAM as well. It is also <br />
&nbsp; &nbsp; slightly faster than the original memset.<br />
&nbsp; &nbsp; \param dst&nbsp; Destination pointer.<br />
&nbsp; &nbsp; \param fill Word to fill with.<br />
&nbsp; &nbsp; \param size Fill-length in bytes.<br />
&nbsp; &nbsp; \note &nbsp; The \a dst pointer and \a size need not be <br />
&nbsp; &nbsp; &nbsp; &nbsp; word-aligned. In the case of unaligned fills, \a fill <br />
&nbsp; &nbsp; &nbsp; &nbsp; will be masked off to match the situation.<br />
*/</span><br />
<span class="kw1">void</span> __toncset(<span class="kw1">void</span> *dst, u32 fill, uint size)<br />
{<br />
&nbsp; &nbsp; <span class="kw1">if</span>(size==<span class="nu0">0</span> || dst==<span class="kw2">NULL</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span>;<br />
<br />
&nbsp; &nbsp; uint left= (u32)dst&amp;<span class="nu0">3</span>;<br />
&nbsp; &nbsp; u32 *dst32= (u32*)(dst-left);<br />
&nbsp; &nbsp; u32 count, mask;<br />
<br />
&nbsp; &nbsp; <span class="co1">// Unaligned head.</span><br />
&nbsp; &nbsp; <span class="kw1">if</span>(left != <span class="nu0">0</span>)<br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Adjust for very small stint.</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span>(left+size&lt;<span class="nu0">4</span>)<br />
&nbsp; &nbsp; &nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask= BIT_MASK(size*<span class="nu0">8</span>)&lt;&lt;(left*<span class="nu0">8</span>); &nbsp; <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dst32= (*dst32 &amp;~ mask) | (fill &amp; mask);<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span>;<br />
&nbsp; &nbsp; &nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; mask= BIT_MASK(left*<span class="nu0">8</span>);<br />
&nbsp; &nbsp; &nbsp; &nbsp; *dst32= (*dst32 &amp; mask) | (fill&amp;~mask);<br />
&nbsp; &nbsp; &nbsp; &nbsp; dst32++;<br />
&nbsp; &nbsp; &nbsp; &nbsp; size -= <span class="nu0">4</span>-left;<br />
&nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; <span class="co1">// Main stint.</span><br />
&nbsp; &nbsp; count= size/<span class="nu0">4</span>;<br />
&nbsp; &nbsp; uint tmp= count&amp;<span class="nu0">3</span>;<br />
&nbsp; &nbsp; count /= <span class="nu0">4</span>;<br />
<br />
&nbsp; &nbsp; <span class="kw1">switch</span>(tmp) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">do</span> {&nbsp; &nbsp; *dst32++ = fill;<br />
&nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">3</span>: &nbsp; &nbsp; *dst32++ = fill;<br />
&nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">2</span>: &nbsp; &nbsp; *dst32++ = fill;<br />
&nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">1</span>: &nbsp; &nbsp; *dst32++ = fill;<br />
&nbsp; &nbsp; <span class="kw1">case</span> <span class="nu0">0</span>: &nbsp; &nbsp; ; } <span class="kw1">while</span>(count--);<br />
&nbsp; &nbsp; }<br />
<br />
&nbsp; &nbsp; <span class="co1">// Tail</span><br />
&nbsp; &nbsp; size &amp;= <span class="nu0">3</span>;<br />
&nbsp; &nbsp; <span class="kw1">if</span>(size)<br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; mask= BIT_MASK(size*<span class="nu0">8</span>);<br />
&nbsp; &nbsp; &nbsp; &nbsp; *dst32= (*dst32 &amp;~ mask) | (fill &amp; mask);<br />
&nbsp; &nbsp; }<br />
}</div></div>

<h4>Discussion</h4>

<p>
Both <code>tonccpy</code> and <code>toncset</code> have the 
following structure: the destination memory is divided into an 
unaligned <dfn>head</dfn>, followed by an aligned <dfn>main stint</dfn> 
and then a <dfn>tail</dfn> for any trailing bytes. In the optimal case there 
is no head (i.e., the destination (and source) are word-aligned) and perhaps 
no tail either (<code>dstv+size</code> is aligned). If that happens you're in 
luck: a 4x unrolled word copier will blaze through memory. And yes, that is a
<a href="http://en.wikipedia.org/wiki/Duff's_device">Duff's Device</a> I'm 
using there; I know it's evil, but I've always wanted to try one. Interestingly, 
it is also the only way I've been able to get DKA to create the optimal output 
for an unrolled loop.
</p>
<p>
When you aren't lucky, you'll have to go through the motions of masking off 
halfwords and/or words to insert the bytes. Technically it's faster to use 
words rather than halfwords, but this can be extremely unpleasant because 
it's also possible for the transfer to be in the middle of a word. For example, 
<code>dst%4== 1</code> and <code>size = 2</code> would require a 
dst-mask of <code>0xFF0000FF</code>. I still have this in 
<code>toncset</code>, but for the copier you have to deal with such 
annoying cases that I preferred to go with the simplicity of halfwords for now.
</p>

<h4>Tests</h4>
<p>
I've tested the routines with all alignment variations and many different sizes 
and found them to work accurately. I've also tested them for speed. The 
following graphics show the results of the tests; while reading, remember 
that all items have been compiled with <code>-O2 -mthumb</code> and are
in ROM. The source data for the copiers was in EWRAM and the destination 
was VRAM.
</p>
<p>
Fig&nbsp;1a and Fig&nbsp;1b show 
<code>tonccpy()</code>, <code>memcpy()</code> and something called 
<code>vramcpy</code>. <code>vramcpy()</code> is a more optimized 
version of <code>tonccpy()</code>, but it's not ready yet. It uses 
<code>memcpy32()</code> for the aligned main stint, so that should 
represent optimal copying speed. The &ldquo;a&rdquo; and &ldquo;u&rdquo;
affixes mean aligned and unaligned pointers, respectively.
</p>
<p>
As you can see, even though <code>tonccpy()</code> is more complicated 
than <code>memcpy()</code>, it's a little faster in almost all cases. Only for short stints is <code>memcpy()</code> faster because 
<code>tonccpy()</code> has a larger overhead. The <code>vramcpy()</code> 
lines show that there is much room for optimization for longer stints. Using 
a dedicated word copier (<code>memcpy32()</code>, DMA) would help, 
but I wanted <code>tonccpy()</code> to be portable and self-sufficient.
</p>
<p>
You can also see the incredible differences between when the source 
and destination have equal alignments (<i>a</i>) and when they don't 
(<i>u</i>). I know it is possible to speed up the unaligned parts by 
50% to 100% or so as well, but I haven't quite zeroed in on the right solution yet.
</p>

<div class=lblock>
<div class=cpt style="width:600px;">
  <img src="/img/post/tonccpy/tonccpy_long.png" id="img-cpy" 
    alt="" /><br />
  <b>Fig 1a</b>: copier comparisons, long stints. 
  <i>a</i>: src=dst alignment; <i>u</i>: unaligned.
</div>

<div class=cpt style="width:600px;">
  <img src="/img/post/tonccpy/tonccpy_short.png"
    alt="" /><br />
  <b>Fig 1b</b>: copier comparisons, short stints.
  <i>a</i>: src=dst alignment; <i>u</i>: unaligned.
</div>
</div><br />

<p>
The results of the fillers are in fig&nbsp;2a and 
fig&nbsp;2b. These pictures show 
<code>toncset()</code>, <code>memset()</code> and 
<code>toncset2()</code>. <code>toncset2()</code> is essentially 
<code>toncset()</code> using <code>memset32()</code> for the 
main stint. Because there's no source alignment to worry about, 
there is no chance for <i>src</i>-<i>dst</i> misalignments. This is why there 
is little difference between the aligned and unaligned cases for the
<code>toncset()</code> variants; only <code>memset()</code> 
is very slow in the unaligned case.
</p>

<div class=lblock>
<div class=cpt style="width:600px;">
  <img src="/img/post/tonccpy/toncset_long.png" id="img-set" 
    alt="" /><br />
  <b>Fig 2a</b>: fill comparisons, long stints. 
  <i>a</i>: dst = aligned; <i>u</i>: unaligned.
</div>

<div class=cpt style="width:600px;">
  <img src="/img/post/tonccpy/toncset_short.png"
    alt="" /><br />
  <b>Fig 2b</b>: fill comparisons, short stints.
  <i>a</i>: dst = aligned; <i>u</i>: unaligned.
</div>
</div><br />

<p>
Lastly, the numbers for the transfer-rate and the overhead for calling 
them. Please remember that the actual numbers depend very much on 
what the waitstates are for the source and destination and where the 
code resides. That said, the figures should be useful for relative 
comparisons. Also, these are GBA timings; the NDS figures will be 
different, but I'll test for them when I get round to it.
</p>

<div class=lblock>
<table>
<tr>
<td>
<table id="tbl-tonccpy"
  border=1 cellpadding=4 cellspacing=0>
<caption align=bottom>
  <b>Table 1</b>: copier results in cycles.
</caption>
<tbody align=right>
<tr>	<td>&nbsp;</td>	<th>rate [c/byte]</th>	<th>overhead [c]</th>	</tr>
<tr>	<th>vramcpy, a</th>	<td>2.219</td>	<td>270</td>	</tr>
<tr>	<th>vramcpy, u</th>	<td>19.520</td>	<td>165</td>	</tr>
<tr>	<th>memcpy, a</th>	<td>6.207</td>	<td>121</td>	</tr>
<tr>	<th>memcpy, u</th>	<td>35.00</td>	<td>84</td>	</tr>
<tr>	<th>tonccpy, a</th>	<td>5.83</td>	<td>167</td>	</tr>
<tr>	<th>tonccpy, u</th>	<td>25.020</td>	<td>151</td>	</tr>
</tbody>
</table>
</td>

<td width=32>&nbsp;</td>

<td>
<table id="tbl-toncset"
  border=1 cellpadding=4 cellspacing=0>
<caption align=bottom>
  <b>Table 2</b>: filler results in cycles.
</caption>
<tbody align=right>
<tr>	<td>&nbsp;</td>	<th>rate [c/byte]</th>	<th>overhead [c]</th>	</tr>
<tr>	<th>toncset2, a</th>	<td>0.656</td>	<td>222</td>	</tr>
<tr>	<th>toncset2, u</th>	<td>0.656</td>	<td>334</td>	</tr>
<tr>	<th>memset, a</th>	<td>3.000</td>	<td>158</td>	</tr>
<tr>	<th>memset, u</th>	<td>23.000</td>	<td>93</td>	</tr>
<tr>	<th>toncset, a</th>	<td>2.81</td>	<td>166</td>	</tr>
<tr>	<th>toncset, u</th>	<td>2.81</td>	<td>266</td>	</tr>
</tbody>
</table>
</tr>
</table>
</div>

<h4>Conclusions</h4>
<p>
<code>tonccpy()</code> and <code>toncset()</code> are essentially 
variations of <code>memcpy()</code> and <code>memset()</code> that 
also work for GBA/NDS VRAM even in the worse circumstances. They're 
actually a little faster as well, so I can recommend using them instead of
<code>memcpy/set</code> in all cases. This is not to say that they are 
the optimal solutions: faster general solutions certainly exist, but they 
will be longer, hairier and probably less portable. Faster non-general 
solutions exist as well, of course. If you know your pointers and sizes 
will be word-aligned, consider DMA32, <code>CpuFastSet</code> or the <code>memcpy32/set32</code> 
routines from tonclib.
</p>
	</div>
	<div class="feedback">
			</div>
</div>


<hr />

<h3 id="comments">
3 Comments<a href="#postcomment" title="Leave a comment"> &raquo;</a>
</h3>

<!== COMMENT START --->
<ol id="commentlist">
  <li class="even" id="comment-2094">
  <div class=pstd>
<p>I've once made C++ templated functions for blitting. One of my goals was to train myself a bit with templates which I rarely use for my own code. This is quite different from your approach though, because it was designed around the blitting features more than the speed. But we share one purpose: being able to blit into VRAM for 8bpp sources. I know a lot about several assemblers mechanics (ALU, registers, adressing modes, flags, etc... I used to spend lot of time to gain some few cycles), but I lack knowledge about ARM op-codes cycles. Since I don't really want to the take time to profile my code (it works and I don't feel it necessary, I'll talk about it below), I'd like to see these templates optimized by someone who run after the cycles... and I'm of the ones who still believe that a human programmer can do a lot better than a compiler, even with today CPU with all their pipelines and stuffs, simply because... we're still smarter than the machines! Other arguments are: gaining few cycles will pay more on a 67Mhz CPU than a multi-Ghz-monster, and the actual optimization is essentially about taking care of that damn critical inner loop.</p>
<p>I've read another article of you on this site about your hesitations to use C++ instead of C. You have good reasons, but I think the performance one is no longer a threat. Effectively, there was a time where C++ compilers performed poorly compared to C compilers. This was not because of the language itself (C++ can be as close to the machine as C can), but because of the compilers themselves, and often because of the programmers who merely know what is costly and what is not once translated into op-codes (those programmers have more reasons to fall in C++ performance traps than others). My point is that templates are not of the features that slow things down. At times, they can become hard to master, must be planned carefully, but their tremendous power is worth thoses prices.</p>
<p>Now about the blitters. The core blitter logic is centralized. Only when it needs to update the actual pixel a function (inlined) is used. This function takes the form of a functor (another C++ feature with no cycle cost, and even potentially faster than function pointers which cannot be inlined). Then you only have to define a new functor to perform special effects at the pixel level (transparency, combininations with source... etc).</p>
<p>Actually, I use 2 blitter templates for everything:</p>
<p>- one for generic blitting from X bpp source to Y bpp destination (usually both are the same and are 16bpp on DS). Note that I also use that for blitting tile-maps on BGs screens, after all, this is just the same as if you had a 16bpp 32x32 pixels screen. The core implementation is pretty simple and I don't think it needs optimizations for the inner loop.</p>
<p>- the other template is intended for paletted-source blits (the specific problem you are talking about). You're right this needs some special processing, because the usual approach is wrong in terms of performance, and even it won't work well if destination is VRAM. This template can blit X bpp paletted images (where X is a templated int of 1, 2, 4 or 8) to a 16bpp bitmap memory (could be templated for 32bpp, not needed on DS though). It reads by chunks of 16bpp for efficiency, taking line bounds alignment into account. It also uses a functor, with slightly different parameters (source is a color index in palette, not the actual color). The generic inner loop is undoubtly slower than yours (mainly due to X bpp source and because I did not really care about performance), but classic head/body/tail methods like yours would speed things up. Of course, template specialization is also possible. I did not put much effort on optimization for this stuff because the DS horsepower definitely doesn't lie in the area of old-school bitmap blitting techniques. Bitmap mode is a commodity on this platform: you can't count on the hardware to help you there (in fact, it will even slows you down more than 90 % of the time since the video needs the data without delay while rendering). If I want moving stuffs, I use OBJs, BGs or 3D polygons, that's it. Blitting is mostly about dealing with big bunches of memory, and a 67Mhz ARM or DMA won't do miracles whatever you do. The DS can make a far better use of its time than blitting bitmaps... so my point is that if I use blitting techniques, I need features over speed. The functor can do this with advanced pixel operations.</p>
<p><b>[[format fairie was here]]</b></p>
<div class="cpp">
<div class="cpp proglist" style=" "><span class="co1">// Here is a sample of the generic simple blit functor:</span></p>
<p><span class="coMULTI">/** Simple copy from source to dest.<br />
&nbsp;*/</span><br />
<span class="kw1">template</span>&lt;<span class="kw1">typename</span> T_SRC, <span class="kw1">typename</span> T_DST&gt;<br />
<span class="kw1">struct</span> simpleCopyFunc : std::binary_function<br />
{<br />
&nbsp; &nbsp; <span class="kw1">void</span> operator() (T_SRC src, T_DST *dst) <span class="kw1">const</span><br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; *dst = src;<br />
&nbsp; &nbsp; }<br />
};</p>
<p><span class="co1">// And the generic transparent blit functor:</span></p>
<p><span class="coMULTI">/** Writes source to destination if source is not of a given value.<br />
&nbsp;*/</span><br />
<span class="kw1">template</span>&lt;<span class="kw1">typename</span> T_SRC, <span class="kw1">typename</span> T_DST&gt;<br />
<span class="kw1">struct</span> transparentCopyFunc : std::binary_function<br />
{<br />
&nbsp; &nbsp; T_SRC trans_;<br />
&nbsp; &nbsp; transparentCopyFunc(T_SRC trans=<span class="nu0">0</span>) :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans_(trans)<br />
&nbsp; &nbsp; {}<br />
&nbsp; &nbsp; <span class="kw1">void</span> <span class="kw1">inline</span> operator() (T_SRC src, T_DST *dst) <span class="kw1">const</span><br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> (src != trans_)<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dst = src;<br />
&nbsp; &nbsp; }<br />
};</p>
<p><span class="co1">// The paletted transparent blit functor (no need to be templated actually):</span></p>
<p><span class="kw1">struct</span> palettedTransparentCopyFunc<br />
{<br />
&nbsp; &nbsp; <span class="kw1">const</span> u16 *pal_;<br />
&nbsp; &nbsp; u8 trans_;<br />
&nbsp; &nbsp; palettedTransparentCopyFunc(<span class="kw1">const</span> u16 *pal, u8 trans=<span class="nu0">0</span>) :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pal_(pal),<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans_(trans)<br />
&nbsp; &nbsp; {}</p>
<p>&nbsp; &nbsp; <span class="kw1">void</span> operator() (u8 src, u16 *&amp;amp;dst) <span class="kw1">const</span><br />
&nbsp; &nbsp; {<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> (src != trans_)<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dst = <span class="nu0">0x8000</span> | pal_[src]; <span class="co1">// Note: the 'OR' can be avoided if palette has all hi-order bits set.</span><br />
&nbsp; &nbsp; }<br />
};</p>
<p><span class="co1">// sample call for paletted blitting:</span><br />
blit(srcAddr, srcPitch,<br />
&nbsp; &nbsp; dstAddr, dstPitch,<br />
&nbsp; &nbsp; srcX, srcY, width, height,<br />
&nbsp; &nbsp; dstX, dstY,<br />
&nbsp; &nbsp; palettedTransparentCopyFunc(palAddr, transColor));</div>
</div>
<p>These are just samples... but you can see that adding effects is as simple as adding a new functor (just copy-paste the simple functor, rename it, and do what is needed for each pixel). Then when you need to blit anything, you simply call the templated blitter function with appropriate arguments (source &amp; destination addresses, source rectangle, destination position (upper-left), source &amp; dest pitches, and functor). Let's be clear: no need for templates to do that, function pointers would work as well (no inline though). I used templates mainly for genericity, so to centralize the blitter logic, nothing else.</p>
<p>The overall code is fairly portable (only u8, u16 should be replaced by uint16_t etc... for better portability). I can share the template code with you if you have an interest. I would be great to have the power of templates alongside well optimized inner loops. So if someday you wanna cross the C++ lines for your blitting stuffs (besides simply being able to overload functions), do not hesitate to contact me. I'd be happy to contribute.</p>
    <div class=info>Comment by Radamanthe &#8212; 2009-02-19 @ <a href="#comment-2094">19:48</a> </div>
  </li>

  <li class="author" id="comment-2095">
  <div class=pstd>
<p>Gah, it looks like the WP sanitizer managed some of the code there (removing the template arguments and such); If you don't mind, I'll try to clean it up a little. </p>
<p>I must say that this is a very interesting approach, one that I probably should look into in the future. With the right kinds of templates, this could make blitting much easier.</p>
<p>I do think optimization has to be considered for large-scale copies such as blits, though. Pixel for pixel copying can be much slower than a hand-assembled asm block transfer routine and because so many pixels have to be considered it can become a bottleneck. However, for more complex functionality like pal->&gt;16bpp and transparent blits, templates can indeed be very helpful.</p>
    <div class=info>Comment by <a href='http://www.coranac.com' rel='external nofollow' class='url'>cearn</a> &#8212; 2009-02-19 @ <a href="#comment-2095">22:45</a> </div>
  </li>

  <li class="even" id="comment-2096">
  <div class=pstd>
<p>Damn, you're right, HTML messed with template syntax (due to ''). Well, I should have used tags for the code, but TBH, I don't know much about HTML :) But you can easily restore them: T_SRC &amp; T_DST are just 'typename' arguments (or 'class', as you wish), and the std::binary_function inheritance can simply be removed (they don't hurt and they're a good habit for STL algorithms which I don't use here anyway). Still, it's not really worth it, since I did not post the core templates code. My first main goal was for the reader to get the point and have some feedbacks.</p>
<p>Let's just say we agree for speed. After all, this is the main purpose of your article and I wouldn't have commented here if I felt it was not that significant.</p>
    <div class=info>Comment by Radamanthe &#8212; 2009-02-20 @ <a href="#comment-2096">13:37</a> </div>
  </li>

</ol>
<!-- COMMENT END -->

<div>
<a href='http://www.coranac.com/2008/01/25/tonccpy/feed/'><abbr title="Really Simple Syndication">RSS</abbr> feed for comments on this post.</a>  <a href="http://www.coranac.com/2008/01/25/tonccpy/trackback/" rel="trackback">TrackBack <abbr title="Universal Resource Locator">URL</abbr></a>
</div>


<h3 id="postcomment">Leave a comment</h3>
<form class=ni action="http://www.coranac.com/wordpress/wp-comments-post.php" method="post" id="commentform">  <input type="text" name="author" id="author"
    value="" size="22" tabindex="1" />
  <label for="author">
    <small>Name (required)</small>
  </label><br />

  <input type="text" name="email" id="email"
    value="" size="22" tabindex="2" />
  <label for="email">
    <small>Mail (will not be published) (required)</small>
  </label><br />

  <input type="text" name="url" id="url"
    value="" size="22" tabindex="3" />
  <label for="url">
    <small>Website</small>
  </label><br />

<p>
  <small>
    <strong>XHTML:</strong> You can use these tags:&lt;a href=&quot;&quot; title=&quot;&quot;&gt; &lt;abbr title=&quot;&quot;&gt; &lt;acronym title=&quot;&quot;&gt; &lt;b&gt; &lt;blockquote cite=&quot;&quot;&gt; &lt;cite&gt; &lt;code&gt; &lt;del datetime=&quot;&quot;&gt; &lt;em&gt; &lt;i&gt; &lt;q cite=&quot;&quot;&gt; &lt;strike&gt; &lt;strong&gt; <br />
    <strong>Others</strong>: [br], [code lang='*'], [color], [url], [wiki]
  </small>
</p>

  <textarea name="comment" id="comment" cols="100%" rows="12" tabindex="4"></textarea><br />

  <input name="submit" type="submit" id="submit" tabindex="5" value="Submit Comment" /><br />
  <input type="hidden" name="comment_post_ID" value="38" /><br />

</form>




<!-- begin footer -->
</div>

<!-- begin sidebar -->
<div id="menu">

<ul>
	<li class="pagenav">Pages:<ul><li class="page_item page-item-2"><a href="http://www.coranac.com/about/" title="About">About</a></li>
<li class="page_item page-item-6"><a href="http://www.coranac.com/documents/" title="Documents">Documents</a></li>
<li class="page_item page-item-10"><a href="http://www.coranac.com/links/" title="links">links</a></li>
<li class="page_item page-item-21"><a href="http://www.coranac.com/projects/" title="Projects">Projects</a></li>
</ul></li>	<li id="linkcat-2" class="linkcat">Blogroll
	<ul class='xoxo blogroll'>
<li><a href="http://www.badastronomy.com/" title="Astronomy related news debunking of heavenly myths.">Bad Astronomy</a></li>
<li><a href="http://www.codinghorror.com/blog/" title="Programming and human factors">Coding Horror</a></li>
<li><a href="http://www.scienceblogs.com/pharyngula/" title="Evolution, development, and random biological ejaculations from a godless liberal">pharyngula</a></li>
<li><a href="http://skeptico.blogs.com/" title="Critical thinking for an irrational world.">Skeptico</a></li>
<li><a href="http://worsethanfailure.com/Default.aspx" title="Curious perversions in information technology">Worse than failure</a></li>

	</ul>
</li>
<li id="linkcat-11" class="linkcat">Internal
	<ul class='xoxo blogroll'>
<li><a href="http://www.coranac.com">home</a></li>
<li><a href="http://www.coranac.com/tonc/text/" title="Tonc hub">Tonc</a></li>

	</ul>
</li>
	<li class="categories">Post categories:<ul>	<li class="cat-item cat-item-58"><a href="http://www.coranac.com/category/blag/" title="View all posts filed under blag">blag</a> (1)
</li>
	<li class="cat-item cat-item-22"><a href="http://www.coranac.com/category/code/" title="Assorted code snippets.">code</a> (11)
</li>
	<li class="cat-item cat-item-3"><a href="http://www.coranac.com/category/doc/" title="View all posts filed under documents">documents</a> (4)
</li>
	<li class="cat-item cat-item-30"><a href="http://www.coranac.com/category/math/" title="View all posts filed under math">math</a> (3)
</li>
	<li class="cat-item cat-item-35"><a href="http://www.coranac.com/category/nds/" title="View all posts filed under nds">nds</a> (3)
</li>
	<li class="cat-item cat-item-4"><a href="http://www.coranac.com/category/proj/" title="View all posts filed under projects">projects</a> (23)
<ul class='children'>
	<li class="cat-item cat-item-7"><a href="http://www.coranac.com/category/proj/grit/" title="The GBA Raster Image Transmogrifier. An open source graphics converter for GBA/NDS. Can convert from almost any image type to any NDS/GBA format. Comes in two flavors: command-line interface (multi-platform) and GUI (windows only).">grit</a> (11)
</li>
	<li class="cat-item cat-item-5"><a href="http://www.coranac.com/category/proj/tonc/" title="A detailed look into GBA programming. Tonc&#039;s text comes in html, chm and pdf. The library code, tonclib, is a mix of C and assembly. The many examples come in C and their binaries are runnable on emulators and hardware.">tonc</a> (12)
</li>
	<li class="cat-item cat-item-6"><a href="http://www.coranac.com/category/proj/usenti/" title="A (usually) simple to use editor for paletted images. It can handle bmp, pcx, png and tga files, has a number of useful palette manipulating tools and can export to GBA/NDS graphics formats.">usenti</a> (4)
</li>
</ul>
</li>
	<li class="cat-item cat-item-29"><a href="http://www.coranac.com/category/tainment/" title="View all posts filed under tainment">tainment</a> (6)
</li>
	<li class="cat-item cat-item-1"><a href="http://www.coranac.com/category/uncategorized/" title="View all posts filed under Uncategorized">Uncategorized</a> (6)
</li>
</ul></li>  <li id="archives">Archives:
	  <select name="cb-archive" style="width:90%;"
	    onChange='document.location.href=this.options[this.selectedIndex].value;'>
	    <option value="">
		  Select Month	    </option>
			<option value='http://www.coranac.com/2009/06/'> June 2009 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2009/05/'> May 2009 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2009/04/'> April 2009 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2009/02/'> February 2009 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2008/12/'> December 2008 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2008/11/'> November 2008 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2008/09/'> September 2008 &nbsp;(4)</option>
	<option value='http://www.coranac.com/2008/08/'> August 2008 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2008/06/'> June 2008 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2008/05/'> May 2008 &nbsp;(5)</option>
	<option value='http://www.coranac.com/2008/04/'> April 2008 &nbsp;(3)</option>
	<option value='http://www.coranac.com/2008/02/'> February 2008 &nbsp;(4)</option>
	<option value='http://www.coranac.com/2008/01/'> January 2008 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2007/12/'> December 2007 &nbsp;(5)</option>
	<option value='http://www.coranac.com/2007/11/'> November 2007 &nbsp;(3)</option>
	<option value='http://www.coranac.com/2007/10/'> October 2007 &nbsp;(4)</option>
	<option value='http://www.coranac.com/2007/06/'> June 2007 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2007/04/'> April 2007 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2007/03/'> March 2007 &nbsp;(2)</option>
	<option value='http://www.coranac.com/2007/02/'> February 2007 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2007/01/'> January 2007 &nbsp;(1)</option>
	<option value='http://www.coranac.com/2006/08/'> August 2006 &nbsp;(1)</option>
	  </select>
  </li>
  <li id="search">
    <label for="s">Search:</label>
    <form id="searchform" method="get" action="http://www.coranac.com">
	<div>
		<input type="text" name="s" id="s" size="16" /><br />
		<input type="submit" value="Search" />
	</div>
	</form>
  </li>
  <li id="meta">Meta:
	<ul>
				<li><a href="http://www.coranac.com/wordpress/wp-login.php">Log in</a></li>
		<li><a href="http://www.coranac.com/feed/" title="Syndicate this site using RSS"><abbr title="Really Simple Syndication">RSS</abbr></a></li>
		<li><a href="http://www.coranac.com/comments/feed/" title="The latest comments to all posts in RSS">Comments <abbr title="Really Simple Syndication">RSS</abbr></a></li>
<!--
		<li><a href="http://validator.w3.org/check/referer" title="This page validates as XHTML 1.0 Transitional">Valid <abbr title="eXtensible HyperText Markup Language">XHTML</abbr></a></li>
		<li><a href="http://gmpg.org/xfn/"><abbr title="XHTML Friends Network">XFN</abbr></a></li>
		<li><a href="http://wordpress.org/" title="Powered by WordPress, state-of-the-art semantic personal publishing platform."><abbr title="WordPress">WP</abbr></a></li>
-->
			</ul>
 </li>

</ul>

<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick" />
<input type="image" src="https://www.paypal.com/en_US/i/btn/x-click-but11.gif" name="submit"
  alt="Please leave a contribution in the leetle box :)" />
<img src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1"  alt=""/>
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
" />
</form>

<div>&nbsp;</div>

<script type="text/javascript"><!--
google_ad_client = "pub-9716169502604225";
/* 120x600 home 20080922 */
google_ad_slot = "0748086420";
google_ad_width = 120;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>
<!-- end sidebar -->

<p class="credit"><!--19 queries. 0.496 seconds. --> <cite>Powered by <a href='http://wordpress.org/' title='Powered by WordPress, state-of-the-art semantic personal publishing platform.'><strong>WordPress</strong></a></cite></p>

</div>

</body>
</html>
<!--
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
</head>
<body>
<p>
My database has called in sick. Please imagine some 
annoying elevator tune till he gets back.
</p>
<p>
<small>[[Doo-di-doo tooo. Dum-di-dum-di-doo-dooo.]]</small>
</p>
</body>
</html>

-->